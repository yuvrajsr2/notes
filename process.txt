Step 1: Plan Your App

Before coding, define:

Features:

User authentication (signup/login)

User list/sidebar

One-on-one chat

Real-time messages

Optional: Image attachments

Tech Stack:

Frontend: React (with Zustand for state)

Backend: Node.js + Express

Database: MongoDB (Mongoose ORM)

Real-time: Socket.io

Image Upload: Cloudinary

Step 2: Set Up the Backend
2.1 Initialize Project
mkdir chat-app
cd chat-app
npm init -y
npm install express mongoose dotenv bcryptjs jsonwebtoken cors socket.io


express → API server

mongoose → MongoDB ODM

dotenv → store secrets

bcryptjs → hash passwords

jsonwebtoken → authentication

cors → allow frontend requests

socket.io → real-time messages

2.2 Connect to MongoDB
import mongoose from 'mongoose';
import dotenv from 'dotenv';
dotenv.config();

mongoose.connect(process.env.MONGO_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
.then(() => console.log("DB Connected"))
.catch(err => console.log(err));

2.3 Create Models

User model

import mongoose from 'mongoose';

const userSchema = new mongoose.Schema({
  username: String,
  email: String,
  password: String,
  profilePic: String,
});

export default mongoose.model("User", userSchema);


Message model

import mongoose from 'mongoose';

const messageSchema = new mongoose.Schema({
  senderId: String,
  receiverId: String,
  text: String,
  image: String,
  createdAt: { type: Date, default: Date.now },
});

export default mongoose.model("Message", messageSchema);

2.4 Authentication Routes

Signup → create user, hash password

Login → validate password, return JWT

import express from 'express';
import User from './models/user.model.js';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

const router = express.Router();

router.post("/signup", async (req,res)=>{
  const {username,email,password} = req.body;
  const hashed = await bcrypt.hash(password, 10);
  const user = await User.create({username,email,password:hashed});
  res.status(201).json(user);
});

router.post("/login", async (req,res)=>{
  const {email,password} = req.body;
  const user = await User.findOne({email});
  const valid = await bcrypt.compare(password,user.password);
  if(!valid) return res.status(400).json({message:"Invalid"});
  const token = jwt.sign({id:user._id}, process.env.JWT_SECRET);
  res.json({token,user});
});


protectRoute middleware verifies JWT before protected endpoints.

2.5 Messages Routes

GET /users → list all users except logged-in

GET /messages/:id → messages between logged-in user and selected user

POST /send/:id → send message to another user

2.6 Integrate Socket.io
import { Server } from "socket.io";
const io = new Server(server, { cors: { origin: "*" } });

io.on("connection", (socket) => {
  console.log("User connected", socket.id);

  socket.on("send-message", (data) => {
    io.to(data.receiverId).emit("receive-message", data);
  });

  socket.on("disconnect", () => {
    console.log("User disconnected", socket.id);
  });
});


Key idea: server listens for messages and broadcasts them to the correct user.

Step 3: Set Up Frontend (React)
3.1 Initialize React
npx create-vite@latest chat-frontend --template react
cd chat-frontend
npm install axios zustand react-hot-toast socket.io-client


axios → API requests

zustand → global state

react-hot-toast → error/success messages

socket.io-client → real-time connection

3.2 Zustand Stores

User store

import { create } from 'zustand';

export const useAuthStore = create((set)=>({
  authUser: null,
  setAuthUser: (user)=>set({authUser:user})
}));


Chat store

import { create } from 'zustand';
import { axiosInstance } from './axios';

export const useChatStore = create((set)=>({
  users: [],
  messages: [],
  selectedUser: null,

  getUsers: async ()=>{
    const res = await axiosInstance.get("/users");
    set({users:res.data});
  },

  getMessages: async (id)=>{
    const res = await axiosInstance.get(`/messages/${id}`);
    set({messages:res.data});
  },

  setSelectedUser: (user)=> set({selectedUser:user})
}));

3.3 Components

Sidebar → list of users

ChatContainer → messages + header + input

MessageInput → send message via API and socket

3.4 Socket.io Client
import { io } from "socket.io-client";
const socket = io("http://localhost:5000");

socket.on("connect", ()=> console.log("connected", socket.id));

socket.on("receive-message", (message)=>{
  // update Zustand messages state
});


Send message: emit event to server

socket.emit("send-message", {receiverId,text});

Step 4: Connecting Frontend & Backend

Use Axios to call protected API routes for users & messages.

Use Zustand to store data globally.

Use Socket.io for live message updates.

Step 5: Testing

Test signup/login

Test fetching users & messages

Test real-time messaging

Test image uploads

Step 6: Deployment

Backend: Railway, Render, Heroku

Frontend: Vercel, Netlify

Make sure CORS is configured correctly.

Set env variables on deployment.
